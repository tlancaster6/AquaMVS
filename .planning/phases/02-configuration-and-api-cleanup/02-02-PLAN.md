---
phase: 02-configuration-and-api-cleanup
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/aquamvs/pipeline.py
  - src/aquamvs/cli.py
  - src/aquamvs/features/extraction.py
  - src/aquamvs/features/matching.py
  - src/aquamvs/features/pairs.py
  - src/aquamvs/features/roma.py
  - src/aquamvs/dense/plane_sweep.py
  - src/aquamvs/dense/roma_depth.py
  - src/aquamvs/fusion.py
  - src/aquamvs/surface.py
  - src/aquamvs/benchmark/runner.py
autonomous: true

must_haves:
  truths:
    - "Pipeline runs end-to-end with new Pydantic config (no AttributeError from renamed fields)"
    - "CLI `aquamvs run config.yaml` works with both old and new config format"
    - "CLI `aquamvs init` generates annotated config in new nested structure"
    - "Long-running operations (plane sweep, depth fusion, pair matching) display tqdm progress bars"
    - "Progress bars suppressed with --quiet flag or in non-TTY contexts"
    - "Cross-stage configuration constraints validated at load time (error before processing starts)"
  artifacts:
    - path: "src/aquamvs/pipeline.py"
      provides: "Updated field access paths for new config structure, tqdm progress bars on slow loops"
    - path: "src/aquamvs/cli.py"
      provides: "Updated config field access, --quiet flag, ValidationError formatting, annotated init output"
  key_links:
    - from: "src/aquamvs/pipeline.py"
      to: "src/aquamvs/config.py"
      via: "config.preprocessing.frame_start (not config.frame_sampling.start), config.reconstruction.num_depths (not config.dense_stereo.num_depths), etc."
    - from: "src/aquamvs/cli.py"
      to: "src/aquamvs/config.py"
      via: "PipelineConfig.from_yaml() with ValidationError handling and format_validation_errors()"
    - from: "src/aquamvs/pipeline.py"
      to: "tqdm"
      via: "tqdm wraps plane sweep camera loop, fusion frame loop, and matching pair loop"
---

<objective>
Update all config consumers (pipeline, CLI, features, dense, fusion, surface, benchmark) to use the new Pydantic config field paths, and add tqdm progress bars to long-running pipeline operations.

Purpose: Plan 01 created the new config structure but didn't update consumers. This plan completes the migration by updating every file that reads config fields, adds progress bars to the three slowest operations (plane sweep, fusion, matching), and updates the CLI with proper ValidationError handling and --quiet support.

Output: Working pipeline with new config structure, progress bars on slow operations, and CLI with proper error formatting.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-configuration-and-api-cleanup/02-RESEARCH.md
@.planning/phases/02-configuration-and-api-cleanup/02-01-SUMMARY.md
@src/aquamvs/pipeline.py
@src/aquamvs/cli.py
@src/aquamvs/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update pipeline.py and all downstream modules for new config structure</name>
  <files>
    src/aquamvs/pipeline.py
    src/aquamvs/features/extraction.py
    src/aquamvs/features/matching.py
    src/aquamvs/features/pairs.py
    src/aquamvs/features/roma.py
    src/aquamvs/dense/plane_sweep.py
    src/aquamvs/dense/roma_depth.py
    src/aquamvs/fusion.py
    src/aquamvs/surface.py
    src/aquamvs/benchmark/runner.py
  </files>
  <action>
**IMPORTANT:** First read `src/aquamvs/config.py` (from plan 01 output) to see the exact field names. Then systematically update every config field access.

The field access path changes in `pipeline.py` are (old -> new):

**Preprocessing:**
- `config.color_norm.enabled` -> `config.preprocessing.color_norm_enabled`
- `config.color_norm.method` -> `config.preprocessing.color_norm_method`
- `config.frame_sampling.start` -> `config.preprocessing.frame_start`
- `config.frame_sampling.stop` -> `config.preprocessing.frame_stop`
- `config.frame_sampling.step` -> `config.preprocessing.frame_step`

**Sparse Matching:**
- `config.feature_extraction` (passed as object) -> need to build equivalent dict/object from `config.sparse_matching` fields
- `config.feature_extraction.extractor_type` -> `config.sparse_matching.extractor_type`
- `config.feature_extraction.max_keypoints` -> `config.sparse_matching.max_keypoints`
- `config.feature_extraction.detection_threshold` -> `config.sparse_matching.detection_threshold`
- `config.feature_extraction.clahe_enabled` -> `config.sparse_matching.clahe_enabled`
- `config.feature_extraction.clahe_clip_limit` -> `config.sparse_matching.clahe_clip_limit`
- `config.pair_selection` (passed as object) -> `config.sparse_matching` (has num_neighbors, include_center)
- `config.matching.filter_threshold` -> `config.sparse_matching.filter_threshold`
- `config.matching` (passed as object) -> need to build from `config.sparse_matching`

**Dense Matching:**
- `config.dense_matching` -> `config.dense_matching` (UNCHANGED — same structure)

**Reconstruction:**
- `config.dense_stereo.num_depths` -> `config.reconstruction.num_depths`
- `config.dense_stereo.cost_function` -> `config.reconstruction.cost_function`
- `config.dense_stereo.window_size` -> `config.reconstruction.window_size`
- `config.dense_stereo.depth_margin` -> `config.reconstruction.depth_margin`
- `config.dense_stereo` (passed as object) -> `config.reconstruction` (or relevant subset)
- `config.fusion.min_consistent_views` -> `config.reconstruction.min_consistent_views`
- `config.fusion.depth_tolerance` -> `config.reconstruction.depth_tolerance`
- `config.fusion.roma_depth_tolerance` -> `config.reconstruction.roma_depth_tolerance`
- `config.fusion.voxel_size` -> `config.reconstruction.voxel_size`
- `config.fusion.min_confidence` -> `config.reconstruction.min_confidence`
- `config.fusion` (passed as object) -> `config.reconstruction` (or relevant subset)
- `config.surface.method` -> `config.reconstruction.surface_method`
- `config.surface.poisson_depth` -> `config.reconstruction.poisson_depth`
- `config.surface.grid_resolution` -> `config.reconstruction.grid_resolution`
- `config.surface` (passed as object) -> `config.reconstruction` (or relevant subset)
- `config.outlier_removal.enabled` -> `config.reconstruction.outlier_removal_enabled`
- `config.outlier_removal.nb_neighbors` -> `config.reconstruction.outlier_nb_neighbors`
- `config.outlier_removal.std_ratio` -> `config.reconstruction.outlier_std_ratio`

**Runtime:**
- `config.device.device` -> `config.runtime.device`
- `config.output.save_features` -> `config.runtime.save_features`
- `config.output.save_depth_maps` -> `config.runtime.save_depth_maps`
- `config.output.save_point_cloud` -> `config.runtime.save_point_cloud`
- `config.output.save_mesh` -> `config.runtime.save_mesh`
- `config.output.keep_intermediates` -> `config.runtime.keep_intermediates`
- `config.output.save_consistency_maps` -> `config.runtime.save_consistency_maps`
- `config.visualization.enabled` -> `config.runtime.viz_enabled`
- `config.visualization.stages` -> `config.runtime.viz_stages`
- `config.evaluation.icp_max_distance` -> `config.runtime.icp_max_distance`
- `config.benchmark.extractors` -> `config.runtime.benchmark_extractors`
- `config.benchmark.clahe` -> `config.runtime.benchmark_clahe`

**Key challenge:** Several downstream functions (like `extract_features_batch`, `match_all_pairs`, `plane_sweep_stereo`, `filter_all_depth_maps`, `reconstruct_surface`, `fuse_depth_maps`, `select_pairs`) accept sub-config objects as parameters. These functions are defined in `features/`, `dense/`, `fusion.py`, `surface.py`. Two approaches:
- **Option A:** Update the function signatures to accept the new grouped config (e.g., `SparseMatchingConfig` instead of `FeatureExtractionConfig`). This is cleaner but touches more files.
- **Option B:** Pass `config.reconstruction` where `config.dense_stereo` or `config.fusion` or `config.surface` was expected, and update the functions to read the correct field names.

**Choose Option A** — update function signatures. For each affected function:
1. Read the current function signature to see what config fields it accesses
2. Change the parameter type to the new grouped config class
3. Update field access inside the function body

**Specific function updates needed:**
- `extract_features_batch(images, config: FeatureExtractionConfig, ...)` -> accept `SparseMatchingConfig`
- `select_pairs(cameras, config: PairSelectionConfig)` -> accept `SparseMatchingConfig`
- `match_all_pairs(features, pairs, ..., config: MatchingConfig, ...)` -> accept `SparseMatchingConfig`
- `match_all_pairs_roma(...)` -> check if it takes config
- `run_roma_all_pairs(...)` -> check if it takes config
- `plane_sweep_stereo(..., config: DenseStereoConfig, ...)` -> accept `ReconstructionConfig`
- `filter_all_depth_maps(ring_cameras, models, depths, confs, config: FusionConfig)` -> accept `ReconstructionConfig`
- `fuse_depth_maps(...)` -> check config usage
- `reconstruct_surface(pcd, config: SurfaceConfig)` -> accept `ReconstructionConfig`
- `roma_warps_to_depth_maps(...)` -> check config usage

**For each file in features/, dense/, fusion.py, surface.py:**
1. Read the file to find config parameter usage
2. Update the type hint to the new config class
3. Update field access inside the function

**Update `_should_viz()` in pipeline.py:**
- `config.visualization.enabled` -> `config.runtime.viz_enabled`
- `config.visualization.stages` -> `config.runtime.viz_stages`

**Update benchmark/runner.py:**
- Read first to understand how it uses config
- Update field accesses to new paths
  </action>
  <verify>
    - `python -c "from aquamvs.pipeline import run_pipeline"` (no import error)
    - `python -c "from aquamvs.features import extract_features_batch, match_all_pairs, select_pairs"` (no import error)
    - `python -c "from aquamvs.dense import plane_sweep_stereo"` (no import error)
    - `python -c "from aquamvs.fusion import filter_all_depth_maps, fuse_depth_maps"` (no import error)
    - `python -c "from aquamvs.surface import reconstruct_surface"` (no import error)
    - `pytest tests/ -x -q --ignore=tests/test_config.py` (no regressions in non-config tests — some may fail if they construct old config objects, fix as needed)
    - `pytest tests/test_config.py -x -q` (config tests still pass)
  </verify>
  <done>
    - All config field access paths updated in pipeline.py and all downstream modules
    - Function signatures updated to accept new grouped config classes
    - No AttributeError when pipeline tries to access config fields
    - All imports work without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CLI with error formatting, --quiet flag, and progress bars</name>
  <files>
    src/aquamvs/pipeline.py
    src/aquamvs/cli.py
  </files>
  <action>
1. **Update `src/aquamvs/cli.py`** config access paths:

   **`run_command()`:**
   - Replace `config.device.device = device` with `config.runtime.device = device`
   - Remove the separate `config.validate()` call — Pydantic validates at construction in `from_yaml()`
   - Catch `ValueError` from `from_yaml()` (which wraps ValidationError) and print formatted error:
     ```python
     try:
         config = PipelineConfig.from_yaml(config_path)
     except ValueError as e:
         print(f"Error: {e}", file=sys.stderr)
         sys.exit(1)
     ```
   - Add `--quiet` flag to `run` subcommand parser:
     ```python
     run_parser.add_argument(
         "-q", "--quiet",
         action="store_true",
         help="Suppress progress bars",
     )
     ```
   - Pass `quiet` to `run_command()` and set `config.runtime.quiet = quiet` before running pipeline

   **`benchmark_command()`:**
   - Remove separate `config.validate()` call
   - Update any config field access paths

   **`export_refs_command()`:**
   - Update `config.calibration_path` (unchanged)
   - Update `config.camera_video_map` (unchanged)
   - Update `config.output_dir` (unchanged)

   **`init_config()`:**
   - Update to generate config with new nested structure
   - When calling `config.to_yaml()`, the new Pydantic model_dump() will naturally produce the nested structure
   - **Annotated YAML output**: After `to_yaml()` saves the config, enhance the output by writing a commented YAML manually. Read the saved file, prepend section comments before each top-level key:
     ```yaml
     # === Required Fields ===
     calibration_path: /path/to/cal.json
     output_dir: /path/to/output
     ...
     # === Preprocessing (color normalization, frame sampling) ===
     preprocessing:
       ...
     # === Sparse Matching (features, pairs, LightGlue) ===
     sparse_matching:
       ...
     ```
   - OR: Implement a `to_annotated_yaml()` method on PipelineConfig that generates commented YAML. This is cleaner but more complex. Use whichever approach is simpler.

   **`preprocess_command()`:** No config changes needed (doesn't use PipelineConfig)
   **`export_mesh_command()`:** No config changes needed (doesn't use PipelineConfig)

2. **Add tqdm progress bars to `src/aquamvs/pipeline.py`**:

   Add `import sys` and `from tqdm import tqdm` at top of pipeline.py.

   **Plane sweep stereo loop** (around line 773, `for ref_name in ctx.ring_cameras:`):
   ```python
   for ref_name in tqdm(
       ctx.ring_cameras,
       desc="Plane sweep stereo",
       disable=config.runtime.quiet or not sys.stderr.isatty(),
       unit="camera",
   ):
   ```

   **Depth fusion** — find where fusion iterates over cameras or frames and wrap with tqdm. The main fusion call is `fuse_depth_maps()` in `fusion.py`. If it has an internal loop over cameras, add tqdm there. If it's a single call, wrap the outer frame loop in `run_pipeline()`:
   ```python
   for frame_idx, raw_images in tqdm(
       videos.iterate_frames(...),
       desc="Processing frames",
       disable=config.runtime.quiet or not sys.stderr.isatty(),
       unit="frame",
   ):
   ```

   **Pair matching** — in `match_all_pairs()` in `features/matching.py`, wrap the pair iteration loop:
   ```python
   from tqdm import tqdm
   for (ref_name, src_name) in tqdm(
       pair_list,
       desc="Matching pairs",
       disable=not sys.stderr.isatty(),  # No config access here; use TTY detection
       unit="pair",
   ):
   ```

   **Important:** Progress bars should use `disable=config.runtime.quiet or not sys.stderr.isatty()` where config is available, or just `disable=not sys.stderr.isatty()` in lower-level functions that don't have config access.

3. **Pass `quiet` through to pipeline:** Add `quiet` parameter to `run_pipeline()` function signature, OR access it from `config.runtime.quiet` (already set in CLI). The latter is cleaner — no signature change needed, just read `config.runtime.quiet` in pipeline.py.

4. **Verify all test files that construct config objects still work.** Run `pytest tests/ -x` to find any failures. The main issue will be tests that import old config class names and construct them directly. These should have been updated in plan 01 (test_config.py), but other test files (test_pipeline.py, test_cli.py, etc.) may also construct configs.

   For each test file that fails:
   - Update imports to use new class names
   - Update constructor calls to use new field names
   - E.g., `PipelineConfig(feature_extraction=FeatureExtractionConfig(...))` becomes `PipelineConfig(sparse_matching=SparseMatchingConfig(...))`
  </action>
  <verify>
    - `python -c "from aquamvs.cli import main"` (no import error)
    - `python -c "from aquamvs.pipeline import run_pipeline"` (no import error)
    - `pytest tests/ -x -q` (all tests pass including config, pipeline, and CLI tests)
    - Manual: `python -m aquamvs --help` shows --quiet on run subcommand
  </verify>
  <done>
    - CLI catches ValidationError and displays formatted error messages with YAML paths
    - `--quiet` flag added to `run` subcommand, suppresses progress bars
    - tqdm progress bars on plane sweep stereo loop, frame processing loop, and pair matching loop
    - Progress bars auto-disable in non-TTY contexts
    - `aquamvs init` generates annotated config with new nested structure
    - All existing tests pass with updated config field paths
    - No runtime errors from config field access in any pipeline code path
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/ -x -q` — all tests pass (config, pipeline, CLI, features, dense, fusion, surface)
2. `python -c "from aquamvs.pipeline import run_pipeline; from aquamvs.config import PipelineConfig"` — no import errors
3. `python -m aquamvs run --help` shows `--quiet` flag
4. `python -m aquamvs init --help` works
5. Old YAML config files load successfully via backward-compatible remapping in from_yaml()
6. Invalid config produces multi-error message with YAML paths
</verification>

<success_criteria>
- Pipeline runs end-to-end with new config structure (no AttributeError)
- CLI handles validation errors gracefully with YAML-path error messages
- `--quiet` flag suppresses progress bars
- tqdm progress bars appear on plane sweep, fusion, and matching (the three slowest operations)
- Progress bars auto-disable in non-TTY contexts
- All existing tests pass
- Both old and new YAML config formats load successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-configuration-and-api-cleanup/02-02-SUMMARY.md`
</output>
