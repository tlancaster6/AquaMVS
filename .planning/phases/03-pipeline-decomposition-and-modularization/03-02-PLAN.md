---
phase: 03-pipeline-decomposition-and-modularization
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/aquamvs/pipeline/stages/__init__.py
  - src/aquamvs/pipeline/stages/undistortion.py
  - src/aquamvs/pipeline/stages/sparse_matching.py
  - src/aquamvs/pipeline/stages/dense_matching.py
  - src/aquamvs/pipeline/stages/depth_estimation.py
  - src/aquamvs/pipeline/stages/fusion.py
  - src/aquamvs/pipeline/stages/surface.py
autonomous: true

must_haves:
  truths:
    - "Each execution path (lightglue, roma+sparse, roma+full) has its matching logic in a separate stage module"
    - "Stage functions are pure functions taking (inputs, context) and returning outputs"
    - "Stages delegate to existing modules (features/, dense/, fusion/, triangulation/) — no logic duplication"
    - "Visualization calls are embedded within their owning stage (not a separate viz stage)"
  artifacts:
    - path: "src/aquamvs/pipeline/stages/__init__.py"
      provides: "Internal stages package marker"
    - path: "src/aquamvs/pipeline/stages/undistortion.py"
      provides: "Undistortion + color normalization stage"
      contains: "def run_undistortion_stage"
    - path: "src/aquamvs/pipeline/stages/sparse_matching.py"
      provides: "LightGlue feature extraction + matching + triangulation + depth ranges"
      contains: "def run_lightglue_path"
    - path: "src/aquamvs/pipeline/stages/dense_matching.py"
      provides: "RoMa dense matching for both sparse and full modes"
      contains: "def run_roma_full_path"
    - path: "src/aquamvs/pipeline/stages/depth_estimation.py"
      provides: "Plane sweep stereo + depth extraction"
      contains: "def run_depth_estimation"
    - path: "src/aquamvs/pipeline/stages/fusion.py"
      provides: "Geometric consistency filtering + depth map fusion + outlier removal"
      contains: "def run_fusion_stage"
    - path: "src/aquamvs/pipeline/stages/surface.py"
      provides: "Surface reconstruction + mesh coloring + save/viz"
      contains: "def run_surface_stage"
  key_links:
    - from: "src/aquamvs/pipeline/stages/sparse_matching.py"
      to: "src/aquamvs/features/"
      via: "imports extract_features_batch, match_all_pairs, select_pairs"
      pattern: "from aquamvs.features import"
    - from: "src/aquamvs/pipeline/stages/dense_matching.py"
      to: "src/aquamvs/dense/"
      via: "imports run_roma_all_pairs, roma_warps_to_depth_maps"
      pattern: "from aquamvs.dense import"
    - from: "src/aquamvs/pipeline/stages/fusion.py"
      to: "src/aquamvs/fusion/"
      via: "imports filter_all_depth_maps, fuse_depth_maps"
      pattern: "from aquamvs.fusion import"
---

<objective>
Extract process_frame's stage logic into separate stage modules under pipeline/stages/.

Purpose: Each execution path (lightglue, roma+sparse, roma+full) becomes a distinct, testable stage module. Stages are internal-only (not exported from pipeline package). This satisfies REF-02 (distinct stage modules per execution path).

Output: 6 stage modules + stages __init__.py, containing all the processing logic from process_frame lines 388-1057.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-pipeline-decomposition-and-modularization/03-RESEARCH.md
@.planning/phases/03-pipeline-decomposition-and-modularization/03-01-SUMMARY.md
@src/aquamvs/pipeline/context.py
@src/aquamvs/pipeline/helpers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create undistortion, sparse matching, and dense matching stage modules</name>
  <files>
    src/aquamvs/pipeline/stages/__init__.py
    src/aquamvs/pipeline/stages/undistortion.py
    src/aquamvs/pipeline/stages/sparse_matching.py
    src/aquamvs/pipeline/stages/dense_matching.py
  </files>
  <action>
    **Reference the ORIGINAL pipeline.py content** (captured in Plan 01 summary or read from git history if needed: `git show HEAD:src/aquamvs/pipeline.py`). Extract these stage functions:

    1. **stages/__init__.py** — Empty file with docstring: `"""Pipeline stage modules (internal — not part of public API)."""`. No exports.

    2. **stages/undistortion.py** — Extract from process_frame lines 388-413:
       - `def run_undistortion_stage(raw_images, ctx) -> tuple[dict[str, np.ndarray], dict[str, torch.Tensor], dict[str, np.ndarray]]`:
         - Filters out None images
         - Undistorts using ctx.undistortion_maps
         - Applies color normalization if config.preprocessing.color_norm_enabled
         - Converts to tensors for feature extraction
         - Computes camera_centers dict
         - Returns (undistorted_numpy, undistorted_tensors, camera_centers)

    3. **stages/sparse_matching.py** — Extract from process_frame lines 502-620:
       - `def run_lightglue_path(undistorted_tensors, ctx, frame_dir) -> dict`:
         - Feature extraction (calls extract_features_batch)
         - Mask application to features
         - Feature matching (calls match_all_pairs)
         - Feature viz (gated by _should_viz)
         - Save features/matches (gated by config)
         - Returns dict with "all_matches" key
       - `def run_triangulation(all_matches, ctx, frame_dir) -> tuple[dict, dict]`:
         - Triangulate all pairs
         - Save sparse cloud
         - Filter sparse cloud
         - Compute depth ranges
         - Returns (sparse_cloud, depth_ranges)

    4. **stages/dense_matching.py** — Extract from process_frame lines 416-499:
       - `def run_roma_full_path(undistorted_tensors, ctx, frame_dir) -> tuple[dict, dict]`:
         - Runs run_roma_all_pairs to get warps
         - Converts warps to depth maps via roma_warps_to_depth_maps
         - Saves depth maps (gated by config)
         - Depth viz (gated by _should_viz)
         - Returns (depth_maps, confidence_maps)
       - `def run_roma_sparse_path(undistorted_tensors, ctx, frame_dir) -> dict`:
         - Runs match_all_pairs_roma for sparse correspondences
         - Saves matches (gated by config)
         - Returns dict with "all_matches" key

    **Critical rules:**
    - Stages are pure extractions — copy logic verbatim from process_frame, adjusting only imports and parameter passing.
    - Import helpers from `..helpers` (e.g., `from ..helpers import _should_viz`).
    - Import PipelineContext from `..context`.
    - Import domain functions from `aquamvs.features`, `aquamvs.dense`, `aquamvs.triangulation`, etc. (absolute imports).
    - Each stage function receives `ctx: PipelineContext` and uses it for config, projection models, pairs, etc.
    - Pass `frame_dir: Path` for I/O operations (saving features, depth maps, viz).
    - Pass `frame_idx: int` for logging.
    - Stages do NOT import from each other.
  </action>
  <verify>
    - `python -c "from aquamvs.pipeline.stages.undistortion import run_undistortion_stage; print('OK')"`
    - `python -c "from aquamvs.pipeline.stages.sparse_matching import run_lightglue_path, run_triangulation; print('OK')"`
    - `python -c "from aquamvs.pipeline.stages.dense_matching import run_roma_full_path, run_roma_sparse_path; print('OK')"`
  </verify>
  <done>
    Three stage modules (undistortion, sparse_matching, dense_matching) contain extracted logic from process_frame. Each function has correct imports and parameter signatures matching the original pipeline.py behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create depth estimation, fusion, and surface stage modules</name>
  <files>
    src/aquamvs/pipeline/stages/depth_estimation.py
    src/aquamvs/pipeline/stages/fusion.py
    src/aquamvs/pipeline/stages/surface.py
  </files>
  <action>
    Continue extracting from process_frame:

    1. **stages/depth_estimation.py** — Extract from process_frame lines 769-856:
       - `def run_depth_estimation(undistorted_tensors, depth_ranges, ctx, frame_dir, frame_idx) -> tuple[dict, dict]`:
         - Iterates over ring cameras with tqdm progress
         - Runs plane_sweep_stereo per camera
         - Extracts depth via extract_depth
         - Applies masks to depth maps
         - Saves depth maps (gated by config)
         - Depth viz (gated by _should_viz)
         - Returns (depth_maps, confidence_maps)

    2. **stages/fusion.py** — Extract from process_frame lines 858-952:
       - `def run_fusion_stage(depth_maps, confidence_maps, undistorted, ctx, frame_dir, frame_idx, skip_filter: bool = False) -> o3d.geometry.PointCloud`:
         - Geometric consistency filtering (skip if skip_filter=True, used by roma+full path)
         - Save consistency maps (gated by config)
         - Depth map fusion
         - Intermediate cleanup (gated by config)
         - Save fused point cloud
         - Statistical outlier removal
         - Returns fused_pcd

    3. **stages/surface.py** — Extract from process_frame lines 954-1057:
       - `def run_surface_stage(fused_pcd, undistorted_tensors, camera_centers, ctx, frame_dir, frame_idx) -> o3d.geometry.TriangleMesh | None`:
         - Surface reconstruction (calls reconstruct_surface)
         - Mesh vertex re-coloring via best_view_colors (ring cameras only)
         - Save mesh
         - Scene visualization
         - Rig diagram visualization
         - Returns mesh or None
       - Also handle the **sparse mode surface** path (lines 622-767 from process_frame):
         - `def run_sparse_surface_stage(sparse_cloud, undistorted_tensors, camera_centers, ctx, frame_dir, frame_idx) -> None`:
           - Converts sparse cloud to Open3D via _sparse_cloud_to_open3d helper
           - Saves point cloud
           - Statistical outlier removal
           - Surface reconstruction
           - Mesh coloring
           - Save mesh
           - Scene viz, rig viz
           - This is the early-return path for sparse mode

    **Same rules as Task 1:** Pure extraction, correct imports, stages don't import each other, use helpers from `..helpers`.
  </action>
  <verify>
    - `python -c "from aquamvs.pipeline.stages.depth_estimation import run_depth_estimation; print('OK')"`
    - `python -c "from aquamvs.pipeline.stages.fusion import run_fusion_stage; print('OK')"`
    - `python -c "from aquamvs.pipeline.stages.surface import run_surface_stage, run_sparse_surface_stage; print('OK')"`
  </verify>
  <done>
    All 6 stage modules exist under pipeline/stages/ with extracted logic covering the complete process_frame execution. Each execution path (lightglue+sparse, lightglue+full, roma+sparse, roma+full) is traceable through distinct stage functions.
  </done>
</task>

</tasks>

<verification>
1. All 7 files exist under `src/aquamvs/pipeline/stages/`
2. Every stage module can be imported without errors
3. No circular imports between stage modules
4. Stage functions delegate to existing domain modules (features/, dense/, fusion/, triangulation/, surface/) — no duplicated logic
5. `git show HEAD:src/aquamvs/pipeline.py` can be compared to verify all process_frame logic is covered by stage modules
</verification>

<success_criteria>
- Each of the 4 execution paths is traceable through distinct stage function(s)
- Stage functions are self-contained with explicit inputs/outputs
- Visualization and I/O operations are embedded in their owning stage, gated by config
- Stages use absolute imports for domain modules and relative imports for pipeline siblings
</success_criteria>

<output>
After completion, create `.planning/phases/03-pipeline-decomposition-and-modularization/03-02-SUMMARY.md`
</output>
