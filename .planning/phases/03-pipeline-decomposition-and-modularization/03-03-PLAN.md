---
phase: 03-pipeline-decomposition-and-modularization
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/aquamvs/pipeline/runner.py
  - src/aquamvs/pipeline/__init__.py
  - src/aquamvs/__init__.py
  - src/aquamvs/cli.py
  - tests/test_pipeline.py
  - tests/test_integration.py
  - .planning/ROADMAP.md
autonomous: true

must_haves:
  truths:
    - "Pipeline class is the primary programmatic entry point: Pipeline(config).run() works"
    - "from aquamvs import Pipeline works (top-level re-export)"
    - "from aquamvs.pipeline import Pipeline works (canonical location)"
    - "CLI aquamvs run still works (uses Pipeline or run_pipeline internally)"
    - "All existing tests pass after import path updates"
    - "AquaCal VideoSet is only imported inside runner.py, not in stages or builder"
  artifacts:
    - path: "src/aquamvs/pipeline/runner.py"
      provides: "Pipeline class + run_pipeline function + process_frame orchestrator"
      contains: "class Pipeline"
    - path: "src/aquamvs/pipeline/__init__.py"
      provides: "Public API exports for pipeline package"
      exports: ["Pipeline", "PipelineContext", "run_pipeline", "setup_pipeline", "process_frame"]
    - path: "src/aquamvs/__init__.py"
      provides: "Top-level re-export of Pipeline"
      contains: "Pipeline"
  key_links:
    - from: "src/aquamvs/pipeline/runner.py"
      to: "src/aquamvs/pipeline/stages/"
      via: "imports stage functions for orchestration"
      pattern: "from .stages"
    - from: "src/aquamvs/pipeline/runner.py"
      to: "src/aquamvs/io.py"
      via: "imports detect_input_type, ImageDirectorySet"
      pattern: "from aquamvs.io import"
    - from: "src/aquamvs/pipeline/runner.py"
      to: "aquacal.io.video"
      via: "imports VideoSet (AquaCal isolation point)"
      pattern: "from aquacal.io.video import VideoSet"
    - from: "src/aquamvs/__init__.py"
      to: "src/aquamvs/pipeline/__init__.py"
      via: "re-exports Pipeline class"
      pattern: "from .pipeline import Pipeline"
    - from: "src/aquamvs/cli.py"
      to: "src/aquamvs/pipeline"
      via: "imports run_pipeline for CLI command"
      pattern: "from aquamvs.pipeline import run_pipeline"
---

<objective>
Create the Pipeline class and runner module, wire up all exports, update imports across CLI and tests, and verify the full decomposition works end-to-end.

Purpose: Complete the pipeline decomposition by creating the public API (Pipeline class), composing stages in the runner, updating all consumers, and making all tests pass. This is the final assembly plan that delivers the working modular pipeline.

Output: Working Pipeline class, updated CLI, passing tests, updated ROADMAP.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-pipeline-decomposition-and-modularization/03-RESEARCH.md
@.planning/phases/03-pipeline-decomposition-and-modularization/03-01-SUMMARY.md
@.planning/phases/03-pipeline-decomposition-and-modularization/03-02-SUMMARY.md
@src/aquamvs/pipeline/__init__.py
@src/aquamvs/pipeline/builder.py
@src/aquamvs/pipeline/stages/
@tests/test_pipeline.py
@tests/test_integration.py
@src/aquamvs/cli.py
@src/aquamvs/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pipeline class and runner module</name>
  <files>
    src/aquamvs/pipeline/runner.py
    src/aquamvs/pipeline/__init__.py
  </files>
  <action>
    1. **Create `runner.py`** with three components:

       **a. `process_frame()` function** — Orchestrates stage calls for a single frame. This replaces the monolithic process_frame from the old pipeline.py. Structure:
       ```python
       def process_frame(frame_idx: int, raw_images: dict[str, np.ndarray], ctx: PipelineContext) -> None:
           # Stage 1: Undistortion
           undistorted, tensors, camera_centers = run_undistortion_stage(raw_images, ctx)
           if not undistorted:
               return

           # Dispatch on matcher type
           if config.matcher_type == "roma" and config.pipeline_mode == "full":
               depth_maps, conf_maps = run_roma_full_path(tensors, ctx, frame_dir, frame_idx)
               fused = run_fusion_stage(depth_maps, conf_maps, undistorted, ctx, frame_dir, frame_idx, skip_filter=True)
           elif config.matcher_type == "roma":
               result = run_roma_sparse_path(tensors, ctx, frame_dir)
               sparse_cloud, depth_ranges = run_triangulation(result["all_matches"], ctx, frame_dir, frame_idx)
               if config.pipeline_mode == "sparse":
                   run_sparse_surface_stage(sparse_cloud, tensors, camera_centers, ctx, frame_dir, frame_idx)
                   return
               depth_maps, conf_maps = run_depth_estimation(tensors, depth_ranges, ctx, frame_dir, frame_idx)
               fused = run_fusion_stage(depth_maps, conf_maps, undistorted, ctx, frame_dir, frame_idx)
           else:  # lightglue
               result = run_lightglue_path(tensors, ctx, frame_dir, frame_idx)
               sparse_cloud, depth_ranges = run_triangulation(result["all_matches"], ctx, frame_dir, frame_idx)
               if config.pipeline_mode == "sparse":
                   run_sparse_surface_stage(sparse_cloud, tensors, camera_centers, ctx, frame_dir, frame_idx)
                   return
               depth_maps, conf_maps = run_depth_estimation(tensors, depth_ranges, ctx, frame_dir, frame_idx)
               fused = run_fusion_stage(depth_maps, conf_maps, undistorted, ctx, frame_dir, frame_idx)

           # Surface reconstruction (full mode)
           run_surface_stage(fused, tensors, camera_centers, ctx, frame_dir, frame_idx)
       ```
       Match the exact behavior of the old process_frame — same logging, same error handling, same early returns.

       **b. `run_pipeline()` function** — The same as old pipeline.py lines 1060-1124. Opens FrameSource (VideoSet or ImageDirectorySet), iterates frames, calls process_frame. This is where AquaCal's VideoSet import lives — the ONLY place in the pipeline package that touches it (satisfying REF-03 isolation).

       **c. `Pipeline` class** — Primary programmatic API per user decision:
       ```python
       class Pipeline:
           """Multi-view stereo reconstruction pipeline.

           Primary programmatic entry point for AquaMVS.

           Example:
               pipeline = Pipeline(config)
               pipeline.run()
           """

           def __init__(self, config: PipelineConfig):
               self.config = config
               self.context = build_pipeline_context(config)

           def run(self) -> None:
               """Run the full reconstruction pipeline."""
               # Same logic as run_pipeline but uses self.context
               # (open frame source, iterate, process_frame, summary viz)
       ```
       The Pipeline.run() method should share implementation with run_pipeline() — either run_pipeline calls Pipeline internally, or both delegate to a shared _run_impl. Pick whichever is cleaner.

    2. **Update `pipeline/__init__.py`** — Final public API:
       ```python
       """Pipeline orchestration for multi-frame reconstruction."""

       from .context import PipelineContext
       from .builder import build_pipeline_context, setup_pipeline
       from .runner import Pipeline, process_frame, run_pipeline

       __all__ = [
           "Pipeline",
           "PipelineContext",
           "build_pipeline_context",
           "setup_pipeline",
           "process_frame",
           "run_pipeline",
       ]
       ```
  </action>
  <verify>
    - `python -c "from aquamvs.pipeline import Pipeline, PipelineContext, run_pipeline, setup_pipeline, process_frame; print('OK')"`
    - `python -c "from aquamvs.pipeline.runner import Pipeline; print('OK')"`
  </verify>
  <done>
    Pipeline class and runner module exist. run_pipeline and process_frame are importable from aquamvs.pipeline. Pipeline class has __init__(config) and run() methods. AquaCal VideoSet is only imported inside runner.py.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update all imports (CLI, tests, __init__.py) and verify</name>
  <files>
    src/aquamvs/__init__.py
    src/aquamvs/cli.py
    tests/test_pipeline.py
    tests/test_integration.py
    .planning/ROADMAP.md
  </files>
  <action>
    1. **Update `src/aquamvs/__init__.py`** — Add Pipeline to the top-level imports:
       ```python
       from .pipeline import (
           Pipeline,
           PipelineContext,
           process_frame,
           run_pipeline,
           setup_pipeline,
       )
       ```
       Add `Pipeline` to `__all__`. Remove `build_pipeline_context` from top-level (keep `setup_pipeline` for existing users). The old import `from aquamvs.pipeline import _should_viz` used in tests needs updating — `_should_viz` is now in `aquamvs.pipeline.helpers`.

    2. **Update `src/aquamvs/cli.py`** — The lazy import `from aquamvs.pipeline import run_pipeline` on line 340 should continue to work unchanged since pipeline/__init__.py re-exports it. Verify no changes needed.

    3. **Update `tests/test_pipeline.py`** — Fix all imports:
       - `from aquamvs.pipeline import _should_viz` → `from aquamvs.pipeline.helpers import _should_viz`
       - `from aquamvs.pipeline import PipelineContext, process_frame, run_pipeline, setup_pipeline` — should work unchanged (re-exported)
       - Fix any uses of old config class names: `OutputConfig` → find where it's imported and update. The test file imports `OutputConfig` and `VizConfig` from `aquamvs.config` — check if these aliases still exist from Phase 02's backward-compat layer. If they don't exist, update to the new config names (`RuntimeConfig` contains output and viz fields).
       - Run `pytest tests/test_pipeline.py` and fix any import errors iteratively.

    4. **Update `tests/test_integration.py`** — Fix imports:
       - `from aquamvs.pipeline import PipelineContext, process_frame` should work unchanged.
       - Run `pytest tests/test_integration.py` and fix any issues.

    5. **Update `ROADMAP.md`** — Per user decision, update Phase 3:
       - Remove success criterion #5 (backward compat with deprecation warnings) — clean break, no shims needed.
       - Update `**Plans:** TBD` → `**Plans:** 3 plans`
       - Update plan list with actual plan descriptions.
       - Keep the Phase 3 goal text but remove "preserving backward compatibility" — replace with "with clean public API".

    6. **Run full test suite**: `pytest tests/ -x` to catch any remaining import issues.
  </action>
  <verify>
    - `python -c "from aquamvs import Pipeline; print('OK')"`
    - `python -c "from aquamvs.pipeline import Pipeline, run_pipeline, setup_pipeline, process_frame, PipelineContext; print('OK')"`
    - `pytest tests/test_pipeline.py -x` passes
    - `pytest tests/test_integration.py -x` passes
    - `pytest tests/ -x` passes (full suite)
  </verify>
  <done>
    All imports updated across CLI, tests, and __init__.py. Pipeline class importable from top-level `aquamvs`. Full test suite passes. ROADMAP updated with Phase 3 plan details and corrected success criteria (no backward-compat requirement).
  </done>
</task>

</tasks>

<verification>
1. `from aquamvs import Pipeline` works
2. `Pipeline(config).run()` is callable (same as `run_pipeline(config)`)
3. CLI `aquamvs run` still works (imports resolve correctly)
4. `pytest tests/ -x` — full test suite passes
5. AquaCal VideoSet is only imported in `pipeline/runner.py` (grep confirms no other pipeline module imports it)
6. ROADMAP.md reflects completed Phase 3 plan structure
</verification>

<success_criteria>
- Pipeline class is the primary programmatic entry point
- from aquamvs import Pipeline works
- CLI and all tests pass without modification to test logic (only import paths change)
- AquaCal VideoSet usage is isolated to runner.py
- ROADMAP updated with plan details and corrected success criteria
</success_criteria>

<output>
After completion, create `.planning/phases/03-pipeline-decomposition-and-modularization/03-03-SUMMARY.md`
</output>
