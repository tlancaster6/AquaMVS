---
phase: 07-post-qa-bug-triage
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aquamvs/profiling/profiler.py
  - src/aquamvs/profiling/__init__.py
autonomous: true

must_haves:
  truths:
    - "When an active profiler is set, timed_stage() delegates to profiler.stage() and captures timing+memory snapshots"
    - "When no active profiler is set, timed_stage() behaves identically to before (log-only)"
    - "Pipeline stages require zero changes — timed_stage signature unchanged"
    - "Thread-local storage ensures profiler state is isolated per thread"
  artifacts:
    - path: "src/aquamvs/profiling/profiler.py"
      provides: "Thread-local profiler registry (set_active_profiler, get_active_profiler) and updated timed_stage"
      exports: ["set_active_profiler", "get_active_profiler", "timed_stage", "PipelineProfiler"]
    - path: "src/aquamvs/profiling/__init__.py"
      provides: "Public exports include new registry functions"
      contains: "set_active_profiler"
  key_links:
    - from: "src/aquamvs/profiling/profiler.py"
      to: "src/aquamvs/pipeline/stages/*.py"
      via: "timed_stage checks for active profiler before each stage"
      pattern: "get_active_profiler"
---

<objective>
Wire the profiler to pipeline stages via thread-local registry pattern.

Purpose: Fix the empty profiler report table (QA issue). Currently `timed_stage()` only logs and `PipelineProfiler.stage()` is never called by pipeline stages. The thread-local registry bridges them without touching any stage files.

Output: Working profiler wiring that the benchmark command (Plan 03) will use to capture per-stage timing.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-post-qa-bug-triage/07-RESEARCH.md

@src/aquamvs/profiling/profiler.py
@src/aquamvs/profiling/__init__.py
@src/aquamvs/profiling/analyzer.py
@src/aquamvs/pipeline/stages/undistortion.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add thread-local profiler registry and update timed_stage</name>
  <files>src/aquamvs/profiling/profiler.py, src/aquamvs/profiling/__init__.py</files>
  <action>
**Thread-local registry** — Add at the top of `profiler.py` (after imports, before `timed_stage`):

```python
import threading

_profiler_local = threading.local()


def set_active_profiler(profiler: "PipelineProfiler | None") -> None:
    """Set the active profiler for the current thread.

    When set, timed_stage() will delegate to profiler.stage() instead of
    just logging elapsed time. Call with None to deactivate.

    Args:
        profiler: PipelineProfiler instance or None to deactivate.
    """
    _profiler_local.instance = profiler


def get_active_profiler() -> "PipelineProfiler | None":
    """Get the active profiler for the current thread, or None.

    Returns:
        Active PipelineProfiler or None if no profiler is active.
    """
    return getattr(_profiler_local, "instance", None)
```

**Update timed_stage** — Replace the existing `timed_stage` context manager with a version that checks for an active profiler:

```python
@contextmanager
def timed_stage(name: str, logger: logging.Logger):
    """Log wall-clock duration of a pipeline stage.

    When an active profiler is set (via set_active_profiler), delegates to
    profiler.stage() to capture detailed timing and memory metrics. Otherwise,
    falls back to simple log-based timing.

    Args:
        name: Stage name (e.g., "depth_estimation").
        logger: Logger instance from the calling module.

    Yields:
        None.
    """
    profiler = get_active_profiler()
    if profiler is not None:
        with profiler.stage(name):
            yield
    else:
        if torch.cuda.is_available():
            torch.cuda.synchronize()
        start = time.perf_counter()
        yield
        if torch.cuda.is_available():
            torch.cuda.synchronize()
        elapsed_ms = (time.perf_counter() - start) * 1000.0
        logger.info("%s: %.1f ms", name, elapsed_ms)
```

The else branch is identical to the current implementation — no behavior change for normal `aquamvs run` usage.

**Update __init__.py** — Add `set_active_profiler` and `get_active_profiler` to the profiling package's `__init__.py` exports and `__all__`.

**Also update profile_pipeline** — The existing `profile_pipeline()` convenience function (lines 144-182) creates a PipelineProfiler but never wires it to `timed_stage`. Fix it by wrapping the `process_frame` call with `set_active_profiler`:

```python
def profile_pipeline(config: PipelineConfig, frame: int = 0) -> ProfileReport:
    ...
    profiler = PipelineProfiler(output_dir=Path(config.output_dir))

    with profiler:
        set_active_profiler(profiler)
        try:
            process_frame(frame, raw_images, ctx)
        finally:
            set_active_profiler(None)

    return profiler.get_report()
```

This fixes the existing `aquamvs profile` command too (until it's replaced by benchmark in Plan 03).
  </action>
  <verify>
1. `python -c "from aquamvs.profiling.profiler import set_active_profiler, get_active_profiler, PipelineProfiler; p = PipelineProfiler(); set_active_profiler(p); assert get_active_profiler() is p; set_active_profiler(None); assert get_active_profiler() is None"` — registry works
2. `python -c "from aquamvs.profiling import set_active_profiler, get_active_profiler"` — exports accessible from package
3. `python -c "
import logging
from aquamvs.profiling.profiler import timed_stage, set_active_profiler, PipelineProfiler
logger = logging.getLogger('test')

# Without profiler — should just log
with timed_stage('test_stage', logger):
    pass

# With profiler — should capture snapshot
p = PipelineProfiler()
set_active_profiler(p)
with timed_stage('test_stage', logger):
    pass
set_active_profiler(None)
assert 'test_stage' in p.snapshots, f'Expected test_stage in snapshots, got {p.snapshots.keys()}'
print('OK: profiler captured stage snapshot')
"` — timed_stage delegates to profiler when active
4. `pytest tests/ -x -q --timeout=30 -k "profil"` — existing profiler tests pass
  </verify>
  <done>Thread-local profiler registry wired into timed_stage. Pipeline stages automatically capture detailed timing+memory when a profiler is active. Zero changes to stage files.</done>
</task>

</tasks>

<verification>
1. Thread-local registry functions exist and are exported from profiling package
2. timed_stage delegates to profiler.stage when active profiler is set
3. timed_stage behaves identically to before when no profiler is active
4. profile_pipeline uses set_active_profiler to wire the profiler
5. All existing tests pass
</verification>

<success_criteria>
- PipelineProfiler.snapshots is populated after running pipeline stages through timed_stage with an active profiler
- No changes required in any pipeline stage file
- Backward-compatible: normal `aquamvs run` unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/07-post-qa-bug-triage/07-02-SUMMARY.md`
</output>
