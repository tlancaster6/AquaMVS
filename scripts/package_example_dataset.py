#!/usr/bin/env python3
"""Package example dataset for AquaMVS from video sources.

This script extracts a single frame from each camera's video and packages it
with calibration and masks into a distributable zip archive.

Maintainer utility - NOT shipped to end users.
"""

import argparse
import re
import zipfile
from pathlib import Path

import cv2


def extract_frame_from_video(video_path: Path, frame_idx: int) -> bytes | None:
    """Extract a single frame from video as PNG bytes.

    Args:
        video_path: Path to MP4 video file
        frame_idx: Frame index to extract (0-based)

    Returns:
        PNG-encoded image bytes, or None if extraction failed
    """
    cap = cv2.VideoCapture(str(video_path))
    try:
        if not cap.isOpened():
            print(f"WARNING: Could not open video: {video_path}")
            return None

        # Seek to desired frame
        cap.set(cv2.CAP_PROP_POS_FRAMES, frame_idx)
        ret, frame = cap.read()

        if not ret:
            print(f"WARNING: Could not read frame {frame_idx} from {video_path}")
            return None

        # Encode as PNG
        success, buffer = cv2.imencode(".png", frame)
        if not success:
            print(f"WARNING: Could not encode frame as PNG from {video_path}")
            return None

        return buffer.tobytes()
    finally:
        cap.release()


def extract_camera_id(filename: str) -> str | None:
    """Extract camera ID from video filename.

    Expected format includes camera ID like 'e3v82e0' somewhere in filename.

    Args:
        filename: Video filename (e.g., '021026_e3v82e0_main.mp4')

    Returns:
        Camera ID string or None if not found
    """
    # Look for pattern like e3v followed by 4 hex characters
    match = re.search(r"(e3v[0-9a-f]{4})", filename.lower())
    if match:
        return match.group(1)
    return None


def generate_config_yaml() -> str:
    """Generate minimal config.yaml content for example dataset."""
    return """# AquaMVS Example Dataset Configuration
# Auto-generated by package_example_dataset.py

# Input sources
image_dir: ./images
calibration: ./calibration.json

# Output
output_dir: ./output

# Camera pattern (extract camera ID from directory names)
camera_pattern: "^([a-z0-9]+)"

# Reconstruction settings
matcher_type: lightglue
pipeline_mode: sparse
device: cpu

# Sparse matching
sparse_matching:
  max_num_keypoints: 2048
  match_threshold: 0.2

# Dense stereo
dense_stereo:
  num_depths: 64
  depth_min: 0.1
  depth_max: 2.0

# Fusion
fusion:
  consistency_threshold: 3
  consistency_min_views: 2

# Visualization
viz:
  save_intermediate: true
  save_clouds: true
  save_meshes: false
"""


def main():
    parser = argparse.ArgumentParser(
        description="Package example dataset from video sources for AquaMVS distribution"
    )
    parser.add_argument(
        "--video-dir",
        type=Path,
        required=True,
        help="Directory containing MP4 video files (one per camera)",
    )
    parser.add_argument(
        "--calibration",
        type=Path,
        required=True,
        help="Path to AquaCal calibration JSON file",
    )
    parser.add_argument(
        "--mask-dir",
        type=Path,
        help="Optional directory containing mask PNGs (one per camera)",
    )
    parser.add_argument(
        "--frame",
        type=int,
        default=0,
        help="Frame index to extract from videos (default: 0)",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("aquamvs-example-dataset.zip"),
        help="Output zip file path (default: aquamvs-example-dataset.zip)",
    )

    args = parser.parse_args()

    # Validate inputs
    if not args.video_dir.is_dir():
        parser.error(f"Video directory not found: {args.video_dir}")
    if not args.calibration.is_file():
        parser.error(f"Calibration file not found: {args.calibration}")
    if args.mask_dir and not args.mask_dir.is_dir():
        parser.error(f"Mask directory not found: {args.mask_dir}")

    # Find video files
    video_files = sorted(args.video_dir.glob("*.mp4"))
    if not video_files:
        parser.error(f"No MP4 files found in {args.video_dir}")

    print(f"Found {len(video_files)} video files in {args.video_dir}")

    # Create zip archive
    camera_count = 0
    with zipfile.ZipFile(args.output, "w", zipfile.ZIP_DEFLATED) as zf:
        # Process each video
        for video_path in video_files:
            camera_id = extract_camera_id(video_path.name)
            if not camera_id:
                print(
                    f"WARNING: Could not extract camera ID from {video_path.name}, skipping"
                )
                continue

            print(f"Processing {camera_id} from {video_path.name}...")

            # Extract frame
            png_bytes = extract_frame_from_video(video_path, args.frame)
            if png_bytes is None:
                continue

            # Add to zip
            image_path = f"images/{camera_id}/frame_{args.frame:06d}.png"
            zf.writestr(image_path, png_bytes)
            camera_count += 1

        # Add masks if provided
        if args.mask_dir:
            mask_files = sorted(args.mask_dir.glob("*.png"))
            print(f"\nFound {len(mask_files)} mask files in {args.mask_dir}")
            for mask_path in mask_files:
                camera_id = extract_camera_id(mask_path.name)
                if not camera_id:
                    print(
                        f"WARNING: Could not extract camera ID from {mask_path.name}, skipping"
                    )
                    continue

                # Add to zip
                mask_archive_path = f"masks/{camera_id}.png"
                zf.write(mask_path, mask_archive_path)
                print(f"  Added mask for {camera_id}")

        # Add calibration
        zf.write(args.calibration, "calibration.json")
        print(f"\nAdded calibration: {args.calibration}")

        # Add config.yaml
        config_content = generate_config_yaml()
        zf.writestr("config.yaml", config_content)
        print("Generated config.yaml")

        # Add README
        readme_path = Path(__file__).parent.parent / "example_data" / "README.md"
        if readme_path.exists():
            zf.write(readme_path, "README.md")
            print(f"Added README: {readme_path}")

    # Print summary
    zip_size_mb = args.output.stat().st_size / (1024 * 1024)
    print(f"\n{'=' * 60}")
    print("Package complete!")
    print(f"  Cameras: {camera_count}")
    print(f"  Frame: {args.frame}")
    print(f"  Output: {args.output.absolute()}")
    print(f"  Size: {zip_size_mb:.1f} MB")
    print(f"{'=' * 60}")


if __name__ == "__main__":
    main()
