#!/usr/bin/env python3
"""Package example dataset for AquaMVS from video sources.

This script extracts multiple frames from each camera's video and packages them
with calibration, masks, and optional temporally-filtered images into a
distributable zip archive.

Maintainer utility - NOT shipped to end users.
"""

import argparse
import re
import shutil
import zipfile
from pathlib import Path

import cv2


def extract_frame_from_video(video_path: Path, frame_idx: int) -> bytes | None:
    """Extract a single frame from video as PNG bytes.

    Args:
        video_path: Path to MP4 video file
        frame_idx: Frame index to extract (0-based)

    Returns:
        PNG-encoded image bytes, or None if extraction failed
    """
    cap = cv2.VideoCapture(str(video_path))
    try:
        if not cap.isOpened():
            print(f"WARNING: Could not open video: {video_path}")
            return None

        cap.set(cv2.CAP_PROP_POS_FRAMES, frame_idx)
        ret, frame = cap.read()

        if not ret:
            print(f"WARNING: Could not read frame {frame_idx} from {video_path}")
            return None

        success, buffer = cv2.imencode(".png", frame)
        if not success:
            print(f"WARNING: Could not encode frame as PNG from {video_path}")
            return None

        return buffer.tobytes()
    finally:
        cap.release()


def get_video_info(video_path: Path) -> dict | None:
    """Get basic video metadata.

    Args:
        video_path: Path to MP4 video file

    Returns:
        Dict with fps, frame_count, duration_s, width, height, or None
    """
    cap = cv2.VideoCapture(str(video_path))
    try:
        if not cap.isOpened():
            return None
        fps = cap.get(cv2.CAP_PROP_FPS)
        frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        return {
            "fps": fps,
            "frame_count": frame_count,
            "duration_s": frame_count / fps if fps > 0 else 0,
            "width": width,
            "height": height,
        }
    finally:
        cap.release()


def extract_camera_id(filename: str) -> str | None:
    """Extract camera ID from video filename.

    Expected format includes camera ID like 'e3v82e0' somewhere in filename.

    Args:
        filename: Video filename (e.g., '021026_e3v82e0_main.mp4')

    Returns:
        Camera ID string or None if not found
    """
    match = re.search(r"(e3v[0-9a-f]{4})", filename.lower())
    if match:
        return match.group(1)
    return None


def compute_frame_indices(
    framestep: int, num_frames: int, total_frames: int, window: int = 30
) -> list[int]:
    """Compute frame indices to extract.

    Matches the output positions of ``process_video_temporal_median`` in
    ``aquamvs.preprocess``, which produces its first output at frame
    ``window - 1`` and then every ``framestep`` frames thereafter.

    Args:
        framestep: Step between frames
        num_frames: Number of frames to extract
        total_frames: Total frames in video
        window: Temporal median window size (default: 30). First output
            frame is at index ``window - 1``.

    Returns:
        List of 0-based frame indices
    """
    start = window - 1
    indices = [start + i * framestep for i in range(num_frames)]
    # Clamp to valid range
    indices = [min(i, total_frames - 1) for i in indices]
    return indices


def generate_config_yaml(camera_ids: list[str], has_filtered: bool) -> str:
    """Generate config.yaml matching the current PipelineConfig schema.

    Args:
        camera_ids: List of camera IDs in the dataset.
        has_filtered: Whether filtered images are included.
    """
    image_subdir = "images/filtered" if has_filtered else "images/unfiltered"

    # Build camera_input_map entries (relative paths inside the zip)
    cam_lines = "\n".join(
        f"  {cam}: ./{image_subdir}/{cam}" for cam in sorted(camera_ids)
    )

    return f"""# AquaMVS Example Dataset Configuration
# Auto-generated by package_example_dataset.py

# Paths (relative to this file's directory)
calibration_path: ./calibration.json
output_dir: ./output

# Camera inputs — maps camera name to its image directory
camera_input_map:
{cam_lines}

# Pipeline settings
matcher_type: roma
pipeline_mode: full

# Runtime
runtime:
  device: cuda

# Reconstruction (defaults are fine for the example dataset)
reconstruction:
  num_depths: 128
  surface_method: poisson
"""


def generate_readme(
    camera_ids: list[str],
    frame_indices: list[int],
    video_info: dict | None,
    has_filtered: bool,
    has_masks: bool,
) -> str:
    """Generate README.md content for the example dataset.

    Args:
        camera_ids: List of camera IDs included
        frame_indices: Frame indices extracted
        video_info: Video metadata dict (from first video)
        has_filtered: Whether filtered images are included
        has_masks: Whether masks are included
    """
    resolution = (
        f"{video_info['width']}x{video_info['height']}" if video_info else "TODO"
    )
    fps = video_info["fps"] if video_info else "TODO"

    frame_list = ", ".join(str(f) for f in frame_indices)

    sections = [
        "# AquaMVS Example Dataset",
        "",
        "## Overview",
        "",
        "Example multi-view image dataset for testing and demonstrating AquaMVS",
        "underwater surface reconstruction. Images are extracted from synchronized",
        "video recorded by an above-water multi-camera ring rig looking down",
        "through a flat water surface.",
        "",
        "## Collection Metadata",
        "",
        "| Field | Value |",
        "|---|---|",
        "| Date | TODO |",
        "| Location | TODO |",
        "| Species / habitat | TODO |",
        f"| Number of cameras | {len(camera_ids)} |",
        f"| Camera IDs | {', '.join(sorted(camera_ids))} |",
        "| Ring cameras | TODO (e.g., 12) |",
        "| Center camera | TODO (e.g., e3v82e0) |",
        "| Ring radius | TODO m |",
        f"| Resolution | {resolution} |",
        f"| Frame rate | {fps} fps |",
        "| Water depth (water_z) | TODO m |",
        "| Refractive index | 1.333 |",
        f"| Frames extracted | {frame_list} |",
        "",
        "## Directory Structure",
        "",
        "```",
    ]

    sections.append("+-- calibration.json        # AquaCal calibration output")
    sections.append("+-- config.yaml             # Example AquaMVS configuration")
    sections.append("+-- README.md               # This file")
    if has_masks:
        sections.append("+-- masks/")
        sections.append("|   +-- {camera_id}.png     # ROI masks (one per camera)")
    sections.append("+-- images/")
    sections.append("    +-- unfiltered/             # Raw extracted frames")
    sections.append("    |   +-- {camera_id}/")
    sections.append("    |       +-- frame_NNNNNN.png")
    if has_filtered:
        sections.append("    +-- filtered/               # Temporally-filtered frames")
        sections.append("        +-- {camera_id}/")
        sections.append("            +-- frame_NNNNNN.png")

    sections.extend(
        [
            "```",
            "",
            "## Usage",
            "",
            "```bash",
            "# Unzip the dataset",
            "unzip aquamvs-example-dataset.zip -d example-dataset",
            "cd example-dataset",
            "",
            "# Run reconstruction on unfiltered images",
            "aquamvs run config.yaml",
            "",
            "# Or point to filtered images instead",
            "aquamvs run config.yaml --image-dir ./images/filtered",
            "```",
            "",
            "## Notes",
            "",
            "- The **unfiltered** images are raw frames extracted directly from video.",
            "- The **filtered** images have temporal median filtering applied to reduce",
            "  surface glint and wave distortion, improving reconstruction quality.",
            "- See the [AquaMVS documentation](https://aquamvs.readthedocs.io/) for",
            "  full pipeline details.",
            "",
        ]
    )

    return "\n".join(sections)


def main():
    parser = argparse.ArgumentParser(
        description="Package example dataset from video sources for AquaMVS distribution"
    )
    parser.add_argument(
        "--video-dir",
        type=Path,
        required=True,
        help="Directory containing MP4 video files (one per camera)",
    )
    parser.add_argument(
        "--calibration",
        type=Path,
        required=True,
        help="Path to AquaCal calibration JSON file",
    )
    parser.add_argument(
        "--mask-dir",
        type=Path,
        help="Optional directory containing mask PNGs (one per camera)",
    )
    parser.add_argument(
        "--filtered-dir",
        type=Path,
        help=(
            "Optional directory of temporally-filtered images. "
            "Expected layout: {filtered-dir}/{camera_id}/frame_NNNNNN.png"
        ),
    )
    parser.add_argument(
        "--framestep",
        type=int,
        default=1800,
        help="Step between extracted frames (default: 1800)",
    )
    parser.add_argument(
        "--num-frames",
        type=int,
        default=5,
        help="Number of frames to extract (default: 5)",
    )
    parser.add_argument(
        "--window",
        type=int,
        default=30,
        help="Temporal median window size — aligns frame indices with filter output (default: 30)",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("aquamvs-example-dataset.zip"),
        help="Output zip file path (default: aquamvs-example-dataset.zip)",
    )
    parser.add_argument(
        "--staging-dir",
        type=Path,
        help=(
            "If provided, write extracted files to this directory instead of "
            "creating a zip. Useful for adding filtered images before zipping."
        ),
    )

    args = parser.parse_args()

    # Validate inputs
    if not args.video_dir.is_dir():
        parser.error(f"Video directory not found: {args.video_dir}")
    if not args.calibration.is_file():
        parser.error(f"Calibration file not found: {args.calibration}")
    if args.mask_dir and not args.mask_dir.is_dir():
        parser.error(f"Mask directory not found: {args.mask_dir}")
    if args.filtered_dir and not args.filtered_dir.is_dir():
        parser.error(f"Filtered image directory not found: {args.filtered_dir}")

    # Find video files
    video_files = sorted(args.video_dir.glob("*.mp4"))
    if not video_files:
        parser.error(f"No MP4 files found in {args.video_dir}")

    # Get video info from first file
    video_info = get_video_info(video_files[0])
    if video_info:
        total_frames = video_info["frame_count"]
        print(
            f"Video info: {video_info['width']}x{video_info['height']} @ "
            f"{video_info['fps']:.0f}fps, {total_frames} frames "
            f"({video_info['duration_s']:.1f}s)"
        )
    else:
        total_frames = args.framestep * args.num_frames
        print("WARNING: Could not read video info, using estimated total frames")

    frame_indices = compute_frame_indices(
        args.framestep, args.num_frames, total_frames, args.window
    )
    print(f"Found {len(video_files)} video files in {args.video_dir}")
    print(f"Extracting frames: {frame_indices}")

    has_filtered = args.filtered_dir is not None
    has_masks = args.mask_dir is not None

    # Decide output mode: staging dir or zip
    if args.staging_dir:
        _write_to_staging_dir(
            args, video_files, frame_indices, video_info, has_filtered, has_masks
        )
    else:
        _write_to_zip(
            args, video_files, frame_indices, video_info, has_filtered, has_masks
        )


def _write_to_staging_dir(
    args,
    video_files: list[Path],
    frame_indices: list[int],
    video_info: dict | None,
    has_filtered: bool,
    has_masks: bool,
):
    """Extract files to a staging directory (for manual filtering before zipping)."""
    staging = args.staging_dir
    staging.mkdir(parents=True, exist_ok=True)

    camera_ids = []

    # Extract unfiltered frames
    for video_path in video_files:
        camera_id = extract_camera_id(video_path.name)
        if not camera_id:
            print(
                f"WARNING: Could not extract camera ID from {video_path.name}, skipping"
            )
            continue

        camera_ids.append(camera_id)
        cam_dir = staging / "images" / "unfiltered" / camera_id
        cam_dir.mkdir(parents=True, exist_ok=True)

        print(f"Processing {camera_id} from {video_path.name}...")
        for frame_idx in frame_indices:
            png_bytes = extract_frame_from_video(video_path, frame_idx)
            if png_bytes is None:
                continue
            out_path = cam_dir / f"frame_{frame_idx:06d}.png"
            out_path.write_bytes(png_bytes)
            print(f"  Extracted frame {frame_idx}")

    # Copy filtered images if provided
    if args.filtered_dir:
        _copy_filtered_images(args.filtered_dir, staging, camera_ids, frame_indices)

    # Copy masks
    if args.mask_dir:
        mask_out = staging / "masks"
        mask_out.mkdir(parents=True, exist_ok=True)
        for mask_path in sorted(args.mask_dir.glob("*.png")):
            camera_id = extract_camera_id(mask_path.name)
            if camera_id:
                shutil.copy2(mask_path, mask_out / f"{camera_id}.png")
                print(f"  Added mask for {camera_id}")

    # Copy calibration
    shutil.copy2(args.calibration, staging / "calibration.json")
    print(f"\nAdded calibration: {args.calibration}")

    # Write config
    config_content = generate_config_yaml(camera_ids, has_filtered)
    (staging / "config.yaml").write_text(config_content, encoding="utf-8")
    print("Generated config.yaml")

    # Write README
    readme_content = generate_readme(
        camera_ids, frame_indices, video_info, has_filtered, has_masks
    )
    (staging / "README.md").write_text(readme_content, encoding="utf-8")
    print("Generated README.md")

    # Create placeholder for filtered images if not provided yet
    if not args.filtered_dir:
        filtered_dir = staging / "images" / "filtered"
        filtered_dir.mkdir(parents=True, exist_ok=True)
        (filtered_dir / ".gitkeep").write_text("")
        print(
            "\nCreated images/filtered/ placeholder — add filtered images before zipping"
        )

    print(f"\n{'=' * 60}")
    print(f"Staging complete: {staging.absolute()}")
    print(f"  Cameras: {len(camera_ids)}")
    print(f"  Frames per camera: {len(frame_indices)}")
    print(
        f"  Filtered images: {'included' if args.filtered_dir else 'TODO — add to images/filtered/'}"
    )
    print(f"\nTo zip: python -m zipfile -c {args.output} {staging}/*")
    print(f"{'=' * 60}")


def _copy_filtered_images(
    filtered_dir: Path,
    staging: Path,
    camera_ids: list[str],
    frame_indices: list[int],
):
    """Copy filtered images from source directory to staging."""
    print("\nCopying filtered images...")
    for camera_id in camera_ids:
        src_cam = filtered_dir / camera_id
        if not src_cam.is_dir():
            print(f"  WARNING: No filtered directory for {camera_id}")
            continue

        dst_cam = staging / "images" / "filtered" / camera_id
        dst_cam.mkdir(parents=True, exist_ok=True)

        for frame_idx in frame_indices:
            src_file = src_cam / f"frame_{frame_idx:06d}.png"
            if src_file.exists():
                shutil.copy2(src_file, dst_cam / src_file.name)
            else:
                print(f"  WARNING: Missing filtered frame {frame_idx} for {camera_id}")


def _write_to_zip(
    args,
    video_files: list[Path],
    frame_indices: list[int],
    video_info: dict | None,
    has_filtered: bool,
    has_masks: bool,
):
    """Write directly to a zip archive."""
    camera_ids = []

    with zipfile.ZipFile(args.output, "w", zipfile.ZIP_DEFLATED) as zf:
        # Process each video — extract unfiltered frames
        for video_path in video_files:
            camera_id = extract_camera_id(video_path.name)
            if not camera_id:
                print(
                    f"WARNING: Could not extract camera ID from {video_path.name}, skipping"
                )
                continue

            camera_ids.append(camera_id)
            print(f"Processing {camera_id} from {video_path.name}...")

            for frame_idx in frame_indices:
                png_bytes = extract_frame_from_video(video_path, frame_idx)
                if png_bytes is None:
                    continue
                image_path = f"images/unfiltered/{camera_id}/frame_{frame_idx:06d}.png"
                zf.writestr(image_path, png_bytes)
                print(f"  Extracted frame {frame_idx}")

        # Add filtered images if provided
        if args.filtered_dir:
            print("\nAdding filtered images...")
            for camera_id in camera_ids:
                src_cam = args.filtered_dir / camera_id
                if not src_cam.is_dir():
                    print(f"  WARNING: No filtered directory for {camera_id}")
                    continue
                for frame_idx in frame_indices:
                    src_file = src_cam / f"frame_{frame_idx:06d}.png"
                    if src_file.exists():
                        arc_path = (
                            f"images/filtered/{camera_id}/frame_{frame_idx:06d}.png"
                        )
                        zf.write(src_file, arc_path)
                    else:
                        print(
                            f"  WARNING: Missing filtered frame {frame_idx} for {camera_id}"
                        )

        # Add masks if provided
        if args.mask_dir:
            mask_files = sorted(args.mask_dir.glob("*.png"))
            print(f"\nFound {len(mask_files)} mask files in {args.mask_dir}")
            for mask_path in mask_files:
                camera_id = extract_camera_id(mask_path.name)
                if not camera_id:
                    print(
                        f"WARNING: Could not extract camera ID from {mask_path.name}, skipping"
                    )
                    continue
                zf.write(mask_path, f"masks/{camera_id}.png")
                print(f"  Added mask for {camera_id}")

        # Add calibration
        zf.write(args.calibration, "calibration.json")
        print(f"\nAdded calibration: {args.calibration}")

        # Add config.yaml
        config_content = generate_config_yaml(camera_ids, has_filtered)
        zf.writestr("config.yaml", config_content)
        print("Generated config.yaml")

        # Add README
        readme_content = generate_readme(
            camera_ids, frame_indices, video_info, has_filtered, has_masks
        )
        zf.writestr("README.md", readme_content)
        print("Generated README.md")

    # Print summary
    zip_size_mb = args.output.stat().st_size / (1024 * 1024)
    print(f"\n{'=' * 60}")
    print("Package complete!")
    print(f"  Cameras: {len(camera_ids)}")
    print(f"  Frames per camera: {len(frame_indices)}")
    print(f"  Output: {args.output.absolute()}")
    print(f"  Size: {zip_size_mb:.1f} MB")
    print(f"{'=' * 60}")


if __name__ == "__main__":
    main()
